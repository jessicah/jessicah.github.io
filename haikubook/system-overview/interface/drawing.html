
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Drawing &#8212; The Haiku Book  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/code.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>The Haiku Book  documentation</span></a></h1>
        <h2 class="heading"><span>Drawing</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="drawing">
<h1>Drawing<a class="headerlink" href="#drawing" title="Permalink to this heading">¶</a></h1>
<p>This section discusses the framework in which <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>s draw. Detailed descriptions of the
functions mentioned here can be found in the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> and <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BWindow</span></code> class
descriptions.</p>
<section id="view-geometry">
<h2>View Geometry<a class="headerlink" href="#view-geometry" title="Permalink to this heading">¶</a></h2>
<p>Each view is assigned a coordinate system of its own. By default, the coordinate origin—(0.0,
0.0)—is located at the left top corner of the view rectangle. The x-axis extends to the right and
the y-axis extends downward; coordinate units count screen pixels. (For a detailed discussion of the
coordinate systems assumed by the Interface Kit, see “The Coordinate Space”)</p>
<p>When a view is added as a child of another view, it’s located within the coordinate system of its
parent. A child is considered part of the contents of the parent view. If the parent moves, the
child moves with it; if the parent view scrolls its contents, the child view is shifted along with
everything else in the view.</p>
<p>Since each view retains its own internal coordinate system no matter who its parent is, where it’s
located within the parent, or where the parent is located, a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>s drawing and
message-handling code doesn’t need to be concerned about anything exterior to itself. Tod o its
work, a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> need look no farther than the boundaries of its own view rectangle.</p>
<section id="frame-and-bounds-rectangles">
<h3>Frame and Bounds Rectangles<a class="headerlink" href="#frame-and-bounds-rectangles" title="Permalink to this heading">¶</a></h3>
<p>Although a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> doesn’t have to look outside its own boundaries, it does have to know
where those boundaries are. It can get this information in two forms:</p>
<ul class="simple">
<li><p>Since a view is located within the coordinate system of its parent, the view rectangle is
initially defined in terms of the parent’s coordinates. This defining rectangle for a view is
known as its frame rectangle. (See the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> constructor and the
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Frame()</span></code> function.)</p></li>
<li><p>When translated from the parent’s coordinates to the internal coordinates of the view itself, the
same rectangle is known as the bounds rectangle. (See the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Bounds()</span></code> function.)</p></li>
</ul>
<p>The following illustration shows a child view 180.0 units wide and 135.0 units high. When viewed
from the outside, from the perspective of its parent’s coordinate system, it has a frame rectangle
with left, top, right, and bottom coordinates at 90.0, 60.0, 270.0, and 195.0. But when viewed from
the inside, in the view’s own coordinate system, it has a bounds rectangle with coordinates at 0.0,
0.0, 180.0, and 135.0:</p>
<p><img alt="Frame Bounds" src="../../_images/frame_bounds.png" /></p>
<p>When a view moves to a new location in its parent, its frame rectangle changes but not its bounds
rectangle. When a view scrolls its contents, its bounds rectangle changes, but not its frame. The
frame rectangle positions the view in the world outside; the bounds rectangle positions the contents
inside the view.</p>
<p>Since a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> does its work in its own coordinate systm, it refers to the bounds
rectangle more often than to the frame rectangle.</p>
</section>
<section id="nonfractional-coordinates">
<h3>Nonfractional Coordinates<a class="headerlink" href="#nonfractional-coordinates" title="Permalink to this heading">¶</a></h3>
<p>Because views are areas within windows and windows are displayed on-screen, the edges of a view must
line up on rows and columns of screen pixels. It’s easy to achieve this result, since coordinate
units correspond to screen pixels; one unit is the distance from the center of a pixel to the center
of an adjacent pixel. Therefore, all you must do is define the view rectangle with nonfractional
coordinates, as in the illustration above.</p>
</section>
<section id="pixel-and-coordinate-dimensions">
<h3>Pixel and Coordinate Dimensions<a class="headerlink" href="#pixel-and-coordinate-dimensions" title="Permalink to this heading">¶</a></h3>
<p>It was mentioned that the child view in the illustration above is 180.0 coordinate units wide and
135.0 units high. However, this view actually covers 181 pixel columns and 136 pixel rows on-screen.</p>
<p>Two facts conspire to determine this result. First, as stated, coordinate units correspond to screen
pixels. Second, the coordinate axes don’t lie between pixels but right in the middle of them. The
x-axis splits a row of pixels and the y-axis runs down the center of a column of pixels; the
coordinate origin where they meet is at the very center of a pixel. Therefore, a view rectangle
covers one more pixel in each direction that its coordinate dimensions would indicate.</p>
<p>Imaging an implausibly tiny frame rectangle like the one in the following diagram:</p>
<p><img alt="Tiny Frame Rectangle" src="../../_images/tiny_frame.png" /></p>
<p>Since the pixels on the edges of this 2.0 * 3.0 rectangle are treated as being inside the rectangle,
the view covers a 3 pixel * 4 pixel area.</p>
<p>This fact is important when laying out views and drawing in the bounds rectangle (or drawing any
rectangle, for that matter). However, when discussing view coordinates and rectangles in general,
it’s easier and more accurate to speak in terms of coordinate values, not pixels—and that’s the
practice in this chapter. However, see “Mapping Coordinates to Pixels” for more on how coordinate
values relate to pixels.</p>
</section>
<section id="scrolling">
<h3>Scrolling<a class="headerlink" href="#scrolling" title="Permalink to this heading">¶</a></h3>
<p>A <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> scrolls its contents by shifting coordinate values within the view
rectangle—that is, by altering the bounds rectangle. If, for example, the top of a view’s bounds
rectangle is at 100.0 and its bottom is at 200.0, scrolling downward 50.0 units would put the top at
150.0 and the bottom at 250.0. Contents of the view with y-coordinate values of 150.0 to 200.0,
originally displayed in the bottom half of the view, would be shifted to the top half. Contents with
y-coordinate values from 200.0 to 250.0, previously unseen, would become visible at the bottom of
the view, as shown in the following illustration:</p>
<p><img alt="Scrolling The View" src="../../_images/scrolling.png" /></p>
<p>Scrolling doesn’t move the view—it doesn’t alter the frame rectangle—it moves only what’s
displayed inside the view. In the illustration above, a “data rectangle” encloses everything the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> is capable of drawing. For example, if the view is able to display an entire
book, the data rectangle would be large enough to enclose all the lines and pages of the book laid
end to end. However, since a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> can draw only within its bounds rectangle,
everything in the data rectangle with coordinates that fall outside the bounds rectangle would be
invisible. To make unseen data visible, the bounds rectangle must change the coordinates that it
encompasses. Scrolling can be though of as sliding the view’s bounds rectangle to a new position on
its data rectangle, as is shown in the illustration above. However, as it appears to the user, it’s
moving the data rectangle under the bounds rectangle. The view doesn’t move; the data does.</p>
</section>
<section id="the-clipping-region">
<h3>The Clipping Region<a class="headerlink" href="#the-clipping-region" title="Permalink to this heading">¶</a></h3>
<p>The Application Server clips the images that a BView produces to the region where it’s permitted to
draw.</p>
<p>This region is never any larger than the view’s bounds rectangle; a view cannot draw outside its
bounds. Furthermore, since a child is considered part of its parent, a view can’t draw outside the
bounds rectangle of its parent either—or, for that matter, outside the bounds rectangle of any
ancestor view. In addition, since child views draw after, and therefore logically in front of, their
parents, a view concedes some of its territory to its children.</p>
<p>Thus, the visible region of a view is the part of its bounds rectangle that’s inside the bounds
rectangles of all its ancestors, minus the frame rectangles of its children. This is illustrated in
the following figure. It shows a hierarchy of three views—X, Y, and Z. The area filled with a
crosshatch pattern is the visible region of view X; it omits the area occupied by its child, view Y.
The visible region of view Y is colored dark gray; it omits the part of the view that lies outside
its parent. View Z has no visible region, for it lies outside the bounds rectangle of its ancestor,
view X:</p>
<p><img alt="View Clipping Outside The Parent" src="../../_images/drawing4.png" /></p>
<p>The visible region of a view might be further restricted if its window is obscured by another window
or if the window it’s in lies partially off-screen. The visible region includes only those areas
that are actually visible to the user. For example, if the three views in the previous illustration
were in a window that was partially blocked by another window, their visible regions might be
considerably smaller. This is shown in the next figure:</p>
<p><img alt="Clipping Areas For Covered Windows" src="../../_images/drawing5.png" /></p>
<p>Note that in this case, view X has a discontinuous visible region.</p>
<p>The Application Server clips the drawing that a view does to a region that’s never any larger than
the visible region. On occasion, it may be smaller. For the sake of efficiency, while a view is
being automatically updated, the clipping region excludes portions of the visible region that don’t
need to be redrawn:</p>
<ul class="simple">
<li><p>When a view is scrolled, the Application Server may be able to shift some of its contents from one
portion of the visible region to another. The clipping region excludes any part of the visible
region that the server was able to update on its own; it includes only the part where the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> must produce images that were not previously visible.</p></li>
<li><p>If a view is resized larger, the clipping region may include only the new areas that were added to
the visible region. (But see the flags argument for the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> constructor.)</p></li>
<li><p>If only part of a view is invalidated (by the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Invalidate()</span></code> function), the
clipping region is the intersection of the visible region and the invalid rectangle.</p></li>
</ul>
<p>An application can also limit the clipping region for a view by passing a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BRegion</span></code>
object to <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ConstrainClippingRegion()</span></code>. The clipping region won’t include any areas
that aren’t in the region passed. The Application Server calculates the clipping region as it
normally would but intersects it with the specified region.</p>
<p>You can obtain the current clipping region for a view by calling
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">GetClippingRegion()</span></code>. (See also the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BRegion</span></code> class description.)</p>
</section>
<section id="the-view-color">
<h3>The View Color<a class="headerlink" href="#the-view-color" title="Permalink to this heading">¶</a></h3>
<p>Every view has a basic, underlying color. It’s the color that fills the view rectangle before the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> does any drawing. The Application Server paints the view with this color before
any view-specific drawing functions are called. The user may catch a glimpse of the color when the
view is first shown on-screen, when it’s resized larger, and when it’s erased in preparation for an
update. It will also be seen wherever the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> fails to draw in the visible region.</p>
<p>In a sense, the view color is the canvas on which the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> draws. It doesn’t enter
into any of the object’s drawing operations except to provide a background. Although it’s one of the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s graphics parameters, it’s not one that any drawing functions refer to.</p>
<p>The default view color is white. You can assign a different color to a view by calling
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetViewColor()</span></code> function. If you set the view color to
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_TRANSPARENT_COLOR</span></code>, the Application Server won’t erase the view’s clipping region
before an update. This is appropriate only if the view erases itself by touching every pixel in the
clipping region when it draws.</p>
</section>
<section id="the-background-bitmap">
<h3>The Background Bitmap<a class="headerlink" href="#the-background-bitmap" title="Permalink to this heading">¶</a></h3>
<p>Every view may additionally have a background bitmap. The Application Server draws this bitmap after
it fills in the view color and before any view-specific drawing functions are called. The view color
will be visible in regions the background bitmap doesn’t cover.</p>
<p>A view begins life without a background bitmap. A background bitmap may be added with
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetViewBitmap()</span></code> function and subsequently removed with
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ClearViewBitmap()</span></code>.</p>
</section>
</section>
<section id="the-mechanics-of-drawing">
<h2>The Mechanics of Drawing<a class="headerlink" href="#the-mechanics-of-drawing" title="Permalink to this heading">¶</a></h2>
<p>Views draw through the following set of primitive functions:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">DrawString()</span></code> draws a string of characters. <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">DrawChar()</span></code> is a
variant of this function; it draws just a single character.</p></li>
<li><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">DrawPicture()</span></code> executes a set of recorded drawing instructions.</p></li>
<li><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">DrawBitmap()</span></code> produces an image from a bitmap.</p></li>
<li><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">CopyBits()</span></code> copies an image from one location to another.</p></li>
<li><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">FillEllipse()</span></code>, <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">FillRegion()</span></code>, and other <code class="docutils literal notranslate"><span class="pre">Fill…()</span></code> functions
fill closed shapes.</p></li>
<li><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">StrokeLine()</span></code>, <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">StrokeArc()</span></code>, and other <code class="docutils literal notranslate"><span class="pre">Stroke…()</span></code> functions
stroke lines along defined paths.</p></li>
<li><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BeginLineArray()</span></code>, <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AddLine()</span></code>, and
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">EndLineArray()</span></code> draw a set of straight lines, all of the same width, but possibly
in different colors.</p></li>
</ul>
<p>The way these functions work depends not only on the values that they’re passed—the particular
string, bitmap, arc, or ellipse that’s to be drawn—but on previously set values in the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s graphics environment.</p>
<section id="graphics-environment">
<h3>Graphics Environment<a class="headerlink" href="#graphics-environment" title="Permalink to this heading">¶</a></h3>
<p>Each <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> object maintains its own graphics environment for drawing. The view
color, coordinate system, and clipping region are fundamental parts of that environment, but not the
only parts. It also includes a number of parameters that can be set and reset at will to affect the
next image drawn. These parameters are:</p>
<ul>
<li><p>Font attributes that determine the appearance of text the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> draws. (See
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetFont()</span></code> and the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BFont</span></code> class.)</p></li>
<li><p>Two pen parameters—a location and a size. The pen location determines where the next drawing will
occur, and the pen size determines the thickness of stroked lines. (See
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">MovePenBy()</span></code> and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetPenSize()</span></code>.)</p></li>
<li><p>Two current colors—a high color and a low color—that can be used either alone or in combination to
form a pattern or halftone. The high color is used for most drawing. The low color is sometimes set
to the underlying view color so that it can be used to erase other drawing or, because it matches
the view background, make it appear that drawing has not touched certain pixels.</p>
<p>(The high and low colors roughly match what other systems call the fore and back, or foreground
and background, colors. However, neither color truly represents the color of the foreground or
background. The terminology high and low is meant to keep the sense of two opposing colors and to
match how they’re defined in a pattern. A pattern bit is turned on for the high color and turned off
for the low color. See the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetHighColor()</span></code> and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetLowColor()</span></code>
functions in the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> class description and the “Patterns” section.</p>
</li>
<li><p>A drawing mode that determines how the next image is to be rendered. (See “Drawing Modes” and the
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetDrawingMode()</span></code> function.)</p></li>
</ul>
<p>By default, a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s graphics parameters are set to the following values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Font</p></td>
<td><p>The system plain font (be_plain_font)</p></td>
</tr>
<tr class="row-even"><td><p>Pen position</p></td>
<td><p>(0.0, 0.0)</p></td>
</tr>
<tr class="row-odd"><td><p>Pen size</p></td>
<td><p>1.0 coordinate units</p></td>
</tr>
<tr class="row-even"><td><p>High color</p></td>
<td><p>Black (red, green, and blue components all equal to 0)</p></td>
</tr>
<tr class="row-odd"><td><p>Low color</p></td>
<td><p>White (red, green, and blue components all equal to 255)</p></td>
</tr>
<tr class="row-even"><td><p>Drawing mode</p></td>
<td><p>Copy mode (<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_COPY</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p>View color</p></td>
<td><p>White (red, green, and blue components all equal to 255)</p></td>
</tr>
<tr class="row-even"><td><p>Clipping region</p></td>
<td><p>The visible region of the view</p></td>
</tr>
<tr class="row-odd"><td><p>Coordinate system</p></td>
<td><p>Origin at the left top corner of the bounds rectangle</p></td>
</tr>
</tbody>
</table>
<p>However, as “Views and the Server” explains, these values have meaning only when the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> is assigned to a window.</p>
</section>
<section id="the-pen">
<h3>The Pen<a class="headerlink" href="#the-pen" title="Permalink to this heading">¶</a></h3>
<p>The pen is a fiction that encompasses two properties of a view’s graphics environment: the
current drawing location and the thickness of stroked lines.</p>
<p>The pen location determines where the next image will be drawn—but only if another location isn’t
explicitly passed to the drawing function. Some drawing functions alter the pen location—as if the
pen actually moves as it does the drawing—but usually it’s set by calling <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">MovePenBy()</span></code> or
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MovePenTo()</span></code>.</p>
<p>The pen that draws lines (through the various <code class="docutils literal notranslate"><span class="pre">Stroke…()</span></code> functions) has a malleable tip that can be
made broader or narrower by calling the calling <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetPenSize()</span></code> function. The
larger the pen size, the thicker the line that it draws.</p>
<p>The pen size is expressed in coordinate units, which must be translated to a particular number of
pixels for the display device. This is done by scaling the pen size to a device-specific value and
rounding to the closest integer. For example, pen sizes of 2.6 and 3.3 would both translate to 3
pixels on-screen, but to 7 and 10 pixels respectively on a 300dpi printer.</p>
<p>The size is never rounded to 0; no matter how small the pen may be, the line never disappears. If
the pen size is set to 0.0, the line will be as thin as possible—it will be drawn using the fewest
possible pixels on the display device. (In other words, it will be rounded to 1 for all devices.)</p>
<p>If the pen size translates to a tip that’s broader than 1 pixel, the line is drawn with the tip
centered on the path of the line. Roughly the same number of pixels are colored on both sides of the
path.</p>
<p>A later section, “Picking Pixels to Stroke and Fill”, illustrates how pens of different sizes choose
the pixels to be colored.</p>
</section>
<section id="colors">
<h3>Colors<a class="headerlink" href="#colors" title="Permalink to this heading">¶</a></h3>
<p>The high and low colors are specified as <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">rgb_color</span></code> values—full 32-bit values with
separate red, green, and blue color components, plus an alpha component for transparency. Although
there may sometimes be limitations on the colors that can be rendered on-screen, there are no
restrictions on the colors that can be specified.</p>
</section>
<section id="color-spaces">
<h3>Color Spaces<a class="headerlink" href="#color-spaces" title="Permalink to this heading">¶</a></h3>
<p>The way colors are specified for a bitmap depends on the color space in which they’re
interpreted. The color space determines the depth of the bitmap data (how many bits of information
are stored for each pixel), the interpretation of the data (whether it represents shades of gray or
true colors, whether it’s segmented into color components, what the components are, and so on), and
the arrangement of components within the data (whether big-endian or little-endian). These six basic
color spaces are recognized:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_GRAY1</span></code></p></td>
<td><p>One bit of data per pixel, where 1 is black and 0 is white.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_GRAY8</span></code></p></td>
<td><p>Eight bits of data per pixel, where a value of 255 is black and 0 is white.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_CMAP8</span></code></p></td>
<td><p>Eight bits of data per pixel, interpreted as an index into a list of 256 colors. The
list is part of the system color map and is the same for all applications.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB15</span></code></p></td>
<td><p>Three components of data per pixel—blue, green, and red, in that order—with 5 bits
each for red, green, and blue. The first bit of the pixel data is not associated with any color
component.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGBA15</span></code></p></td>
<td><p>Four components of data per pixel—blue, green, red, and alpha, in that order—with 5
bits each for red, green, and blue, and 1 bit for alpha.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB16</span></code></p></td>
<td><p>Three components of data per pixel—blue, green, and red, in that order—with 5 bits
each for red and blue, and 6 bits for green.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB32</span></code></p></td>
<td><p>Four components of data per pixel—blue, green, red, and alpha, in that order—with 8
bits per component. A component value of 255 yields the maximum amount of red, green, or blue,
and a value of 0 indicates the absence of that color.</p></td>
</tr>
</tbody>
</table>
<p>The components in the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB32</span></code>, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB16</span></code>, and <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB15</span></code> color spaces
are meshed rather than separated into distinct planes; all four components are specified for the
first pixel before the four components for the second pixel, and so on. The order of bytes for these
two types is little-endian, which means that for <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB32</span></code> data, the component bytes
appear in the order blue, green, red, and alpha.</p>
<p>Counterpart color spaces are defined for big-endian data. <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB32_BIG</span></code>,
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGBA16_BIG</span></code>, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGBA15_BIG</span></code>, and <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB15_BIG</span></code>, are equivalent to
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB32</span></code>, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB16</span></code>, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGBA15</span></code>, and <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB15</span></code>—except for
the order of bytes. The Be operating system retains data in the little-endian formats; the
big-endian color spaces are defined only to label noncompatible data that the system must convert
and to allow drivers to communicate precise formats to the operating system.</p>
<p>Alpha should be 0 for 100% transparent, or 255 (for 8-bit alpha channels) for 100% opaque. For 1-bit
alpha channels, a value of 1 indicates opaque.</p>
</section>
<section id="the-screen">
<h3>The Screen<a class="headerlink" href="#the-screen" title="Permalink to this heading">¶</a></h3>
<p>The screen can be configured to display colors in either the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_CMAP8</span></code>,
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB15</span></code>, or <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB32</span></code> color spaces. When it’s in the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_CMAP8</span></code> or
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB15</span></code> color spaces, specified rgb_colors are displayed as the closest available color.
(See the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBitmap</span></code> and <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BScreen</span></code> classes.)</p>
</section>
<section id="patterns">
<h3>Patterns<a class="headerlink" href="#patterns" title="Permalink to this heading">¶</a></h3>
<p>Most functions that stroke a line or fill a closed shape don’t draw directly in either the
high or the low color. Rather they take a pattern, an arrangement of one or both colors that’s
repeated over the entire surface being drawn. A pattern might consist of just the high color, just
the low color, or some combination of the two.</p>
<p>By combining the low color with the high color, patterns can produce dithered colors that lie
somewhere between two hues in the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_CMAP8</span></code> color space. Patterns also permit drawing with
less than the solid high color (for intermittent or broken lines, for example) and can take
advantage of drawing modes that treat the low color as if it were transparent, as discussed in the
next section.</p>
<p>A pattern is defined as an 8-pixel by 8-pixel square. The pattern type is 8 bytes long, with 1 byte
per row and 1 bit per pixel. Rows are specified from top to bottom and pixels from left to right.
Bits marked 1 designate the high color; those marked 0 designate the low color. For example, a
pattern of wide diagonal stripes could be defined as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pattern</span> <span class="n">stripes</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xc7</span><span class="p">,</span> <span class="mh">0x8f</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x3e</span><span class="p">,</span>
                    <span class="mh">0x7c</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0xf1</span><span class="p">,</span> <span class="mh">0xe3</span> <span class="p">};</span>
</pre></div>
</div>
<p>Patterns repeat themselves across the screen, like tiles laid side by side. The pattern defined
above looks like this:</p>
<p><img alt="Fill Patterns" src="../../_images/fill_pattern.png" /></p>
<p>The dotted lines in this illustration show the separation of the screen into pixels. The thicker
black line outlines one 8 * 8 square that the pattern defines.</p>
<p>The outline of the shape being filled or the width of the line being stroked determines where the
pattern is revealed. It’s as if the screen was covered with the pattern just below the surface, and
stroking or filling allowed some of it to show through. For example, stroking a 1-pixel wide
horizontal path in the pattern illustrated above would result in a dotted line, with the dashes (in
the high color) slightly longer than the spaces between (in the low color):</p>
<p><img alt="Line Patterns" src="../../_images/line_pattern.png" /></p>
<p>When stroking a line or filling a shape, the pattern serves as the source image for
the current drawing mode, as explained in “Drawing Modes” next. The nature of the mode determines
how the pattern interacts with the destination image, the image already in place.</p>
<p>The Interface Kit defines three patterns:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_SOLID_HIGH</span></code></p></td>
<td><p>Consists only of the high color.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_SOLID_LOW</span></code></p></td>
<td><p>Has only the low color.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_MIXED_COLORS</span></code></p></td>
<td><p>Mixes the two colors evenly, like the pattern on a checkerboard.</p></td>
</tr>
</tbody>
</table>
<p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_SOLID_HIGH</span></code> is the default pattern for all drawing functions. Applications can define
as many other patterns as they need.</p>
</section>
<section id="drawing-modes">
<h3>Drawing Modes<a class="headerlink" href="#drawing-modes" title="Permalink to this heading">¶</a></h3>
<p>When a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> draws, it in effect transfers an image to a target location somewhere in
the view rectangle. The drawing mode determines how the image being transferred interacts with the
image already in place at that location. The image being transferred is known as the source image;
it might be a bitmap or a pattern of some kind. The image already in place is known as the
destination image.</p>
<p>In the simplest and most straightforward kind of drawing, the source image is simply painted over
the destination; the source replaces the destination. However, there are other possibilities. There
are ten different drawing modes—ten distinct ways of combining the source and destination images.
The modes are designated by drawing_mode constants that can be passed to
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetDrawingMode()</span></code>:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_COPY</span></code></p></td>
<td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_ADD</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_OVER</span></code></p></td>
<td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_SUBTRACT</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_ERASE</span></code></p></td>
<td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_BLEND</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_INVERT</span></code></p></td>
<td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_MIN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_SELECT</span></code></p></td>
<td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_MAX</span></code></p></td>
</tr>
</tbody>
</table>
<p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_COPY</span></code> is the default mode and the simplest. It transfers the source image to the
destination, replacing whatever was there before. The destination is ignored.</p>
<p>In the other modes, however, some of the destination might be preserved, or the source and
destination might be combined to form a result that’s different from either of them. For these
modes, it’s convenient to think of the source image as an image that exists somewhere independent of
the destination location, even though it’s not actually visible. It’s the image that would be
rendered at the destination in <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_COPY</span></code> mode.</p>
</section>
<section id="bitmaps-and-patterns">
<h3>Bitmaps and Patterns<a class="headerlink" href="#bitmaps-and-patterns" title="Permalink to this heading">¶</a></h3>
<p>The modes work for all <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> drawing functions—including those that stroke lines and
fill shapes, those that draw characters, and those that image bitmaps. The way they work depends
foremost on the nature of the source image—whether it’s a pattern or a bitmap. For the <code class="docutils literal notranslate"><span class="pre">Fill…()</span></code> and
<code class="docutils literal notranslate"><span class="pre">Stroke…()</span></code> functions, the source image is a pattern that has the same shape as the area being
filled or the area the pen touches as it strokes a line. For <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">DrawBitmap()</span></code>, the
source image is a rectangular bitmap.</p>
<p>In a sense, a pattern is simply a bitmap that’s one bit deep. It’s a bitmap consisting of two
colors, one which maps to the current high color and another that maps to the current low color. As
we shall see later, a <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_MONOCHROME_1_BIT</span></code> bitmap acts just like a pattern. However,
patterns and bitmaps generally behave differently:</p>
<ul class="simple">
<li><p>Only a source pattern has designated high and low colors. Even if a source bitmap has colors that
match the current high and low colors, they’re not handled like the colors in a pattern; they’re
treated just like any other color in the bitmap.</p></li>
<li><p>On the other hand, only a source bitmap can have transparent pixels. In the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_CMAP8</span></code>
color space, a pixel is made transparent by assigning it the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_TRANSPARENT_MAGIC_CMAP8</span></code>
value. In the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB32</span></code> color space, a pixel assigned the
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_TRANSPARENT_MAGIC_RGBA32</span></code> value is considered transparent. These values have meaning
only for source bitmaps, not for source patterns. If the current high or low color in a pattern
happens to have a transparent value, it’s still treated as the high or low color, not like
transparency in a bitmap. For big endian color spaces, the transparency color should be byte-swapped
from its little endian counterpart.</p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_TRANSPARENT_MAGIC_CMAP8</span></code></p></td>
<td><p>8-bit indexed color transparent pixel.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_TRANSPARENT_MAGIC_RGBA15</span></code></p></td>
<td><p>15-bit transparent pixel.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_TRANSPARENT_MAGIC_RGBA15_BIG</span></code></p></td>
<td><p>15-bit transparent pixel, big-endian.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_TRANSPARENT_MAGIC_RGBA32</span></code></p></td>
<td><p>32-bit transparent pixel.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_TRANSPARENT_MAGIC_RGBA32_BIG</span></code></p></td>
<td><p>32-bit transparent pixel, big-endian.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="drawing-modes-and-color-spaces">
<h3>Drawing Modes and Color Spaces<a class="headerlink" href="#drawing-modes-and-color-spaces" title="Permalink to this heading">¶</a></h3>
<p>The way the drawing modes work also depends on the color space of the source image and the color
space of the destination. The following discussion concentrates on drawing where the source and
destination both contain colors. This is the most common case, and also the one that’s most general.</p>
<p>The source and destination images can have different color spaces. For example, a source bitmap
might be defined in the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_CMAP8</span></code> space while the destination is displayed in the full
color <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB32</span></code> color space. The drawing operation merely combines the colors in the two
images in some way. It doesn’t transfer the color space of the source image to the destination. The
image that results from the drawing operation will always be in the color space of the destination
image.</p>
</section>
<section id="mode-definitions">
<h3>Mode Definitions<a class="headerlink" href="#mode-definitions" title="Permalink to this heading">¶</a></h3>
<p>When applied to colors, the ten drawing modes fall naturally into four groups:</p>
<ul class="simple">
<li><p>The <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_COPY</span></code> mode, which copies the source image to the destination.</p></li>
<li><p>The <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_OVER</span></code>, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_ERASE</span></code>, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_INVERT</span></code>, and
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_SELECT</span></code> modes, which—despite their differences—all treat the low color in a pattern
as if it were transparent.</p></li>
<li><p>The <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_ADD</span></code>, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_SUBTRACT</span></code>, and <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_BLEND</span></code> modes, which
combine colors in the source and destination images.</p></li>
<li><p>The <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_MIN</span></code> and <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_MAX</span></code> modes, which choose between the source and
destination colors.</p></li>
</ul>
<p>The following paragraphs describe each of these groups in turn.</p>
<section id="copy-mode">
<h4>Copy Mode<a class="headerlink" href="#copy-mode" title="Permalink to this heading">¶</a></h4>
<p>In <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_COPY</span></code> mode, the source image replaces the destination. This is the default drawing
mode and the one most commonly used. Because this mode doesn’t have to test for particular color
values in the source image, look at the colors in the destination, or compute colors in the result,
it’s also the fastest of the modes.</p>
<p>If the source image contains transparent pixels, their transparency will be retained in the result;
the transparent value is copied just like any other color. However, the appearance of a transparent
pixel when shown on-screen is indeterminate. If a source image has transparent portions, it’s best
to transfer it to the screen in B_OP_OVER or another mode. In all modes other than B_OP_COPY, a
transparent pixel in a source bitmap preserves the color of the corresponding destination pixel.</p>
</section>
<section id="transparency-modes">
<h4>Transparency Modes<a class="headerlink" href="#transparency-modes" title="Permalink to this heading">¶</a></h4>
<p>Four drawing modes—<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_OVER</span></code>, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_ERASE</span></code>, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_INVERT</span></code>, and
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_SELECT</span></code>—are designed specifically to make use of transparency in the source image;
they’re able to preserve some of the destination image. In these modes (and only these modes) the
low color in a source pattern acts just like transparency in a source bitmap.</p>
<p>Each of these modes has a different effect on the destination image—but only in those places where
the source image is not transparent. One of the modes, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_OVER</span></code>, transfers some of the
source image to the destination. The other three modes play with the destination in some way—erase
it, invert it, or select colors in it—without regard to the source image. For these modes, the only
thing that matters about the source image is where it’s transparent and where it’s not. Each of the
four modes is described below:</p>
<ul>
<li><p>The <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_OVER</span></code> mode places the source image “over” the destination; the source provides
the foreground and the destination the background. In this mode, the source image replaces the
destination image (just as in the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_COPY</span></code> mode)—except where a source bitmap has
transparent pixels and a source pattern has the low color. Transparency in a bitmap and the low
color in a pattern retain the destination image in the result.</p></li>
<li><p>By masking out the unwanted parts of a rectangular bitmap with transparent pixels, this mode can
place an irregularly shaped source image in front of a background image. Transparency in the source
foreground lets the destination background show through. The versatility of <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_OVER</span></code> makes it the
second most commonly used mode, after <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_COPY</span></code>.</p></li>
<li><p>The <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_ERASE</span></code> mode doesn’t draw the source image at all. Instead, it erases the destination image.
Like <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_OVER</span></code>, it preserves the destination image wherever a source bitmap is transparent or a
source pattern has the low color. But everywhere else—where the source bitmap isn’t transparent and
the source pattern has the high color—it removes the destination image, replacing it with the low
color.</p>
<p>Although this mode can be used for selective erasing, it’s simpler to erase by filling an area with
the B_SOLID_LOW pattern in <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_COPY</span></code> mode.</p>
</li>
<li><p>The <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_INVERT</span></code> mode, like <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_ERASE</span></code>, doesn’t draw the source image.
Instead, it inverts the colors in the destination image. As in the case of the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_OVER</span></code>
and <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_ERASE</span></code> modes, where a source bitmap is transparent or a source pattern has the
low color, the destination image remains unchanged in the result. Everywhere else, the color of the
destination image is inverted.</p>
<p>The inversion of an rgb_color is the complement of its color components. For example, the inversion
of a red value of 58 would be 197 (255 - 58).</p>
</li>
<li><p>The <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_SELECT</span></code> mode also doesn’t draw the source image. It replaces the high color in the
destination image with the low color and the low color with the high color. As for the other modes
in this group, where a source bitmap is transparent or a source pattern has the low color, the
destination image remains unchanged in the result. Everywhere else, the high and low colors are
switched.</p>
<p>This is similar to the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_INVERT</span></code> mode, except that <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_SELECT</span></code> affects
at most only two colors in the destination image. The destination is preserved not only where the
source is transparent, but also where its colors don’t match the current high and low colors.</p>
</li>
</ul>
<p>These four modes also work for monochrome images. If the source image is monochrome, the distinction
between source bitmaps and source patterns breaks down. Two rules apply:</p>
<ul class="simple">
<li><p>If the source image is a monochrome bitmap, it acts just like a pattern. A value of 1 in the bitmap
designates the current high color, and a value of 0 designates the current low color. Thus, 0,
rather than B_TRANSPARENT_MAGIC_*, becomes the transparent value.</p></li>
<li><p>If the source and destination are both monochrome, the high color is necessarily black (1), and
the low color is necessarily white (0)—but otherwise the drawing modes work as described. With the
possible colors this severely restricted, the three modes are reduced to boolean operations:
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_OVER</span></code> is the same as a logical OR, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_INVERT</span></code> and
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_SELECT</span></code> are the same as logical exclusive OR, and <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_ERASE</span></code> is the same
as an inversion of logical AND.</p></li>
</ul>
</section>
<section id="blending-modes">
<h4>Blending Modes<a class="headerlink" href="#blending-modes" title="Permalink to this heading">¶</a></h4>
<p>Three drawing modes—<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_ADD</span></code>, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_SUBTRACT</span></code>, and
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_BLEND</span></code>—combine the source and destination images, pixel by pixel, and color
component by color component. As in most of the other modes, transparency in a source bitmap
preserves the destination image in the result. Elsewhere, the result is a combination of the source
and destination. The high and low colors of a source pattern aren’t treated in any special way;
they’re handled just like other colors.</p>
<ul>
<li><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_ADD</span></code> adds each component of the source color to the corresponding component of the
destination color, with a component value of 255 as the limit. Colors become brighter, closer to
white.</p>
<p>By adding a uniform gray to each pixel in the destination, for example, the whole destination
image can be brightened by a constant amount.</p>
</li>
<li><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_SUBTRACT</span></code> subtracts each component of the source color from the corresponding
component of the destination color, with a component value of 0 as the limit. Colors become darker,
closer to black.</p>
<p>For example, by subtracting a uniform amount from the red component of each pixel in the
destination, the whole image can be made less red.</p>
</li>
<li><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_BLEND</span></code> averages each component of the source and destination colors (adds the
source and destination components and divides by 2). The two images are merged into one.</p></li>
</ul>
<p>These modes work only for color images, not for monochrome ones. If the source or destination is
specified in the B_CMAP8 color space, the color will be expanded to a full <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_RGB32</span></code> value
to compute the result; the result is then contracted to the closest color in the <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_CMAP8</span></code>
color space.</p>
</section>
<section id="selection-modes">
<h4>Selection Modes<a class="headerlink" href="#selection-modes" title="Permalink to this heading">¶</a></h4>
<p>Two drawing modes—<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_MAX</span></code> and <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_MIN</span></code>—compare each pixel in the source
image to the corresponding pixel in the destination image and select one to keep in the result. If
the source pixel is transparent, both modes select the destination pixel. Otherwise,
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_MIN</span></code> selects the darker of the two colors and <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_MAX</span></code> selects the
brighter of the two. If the source image is a uniform shade of gray, for example,
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_MAX</span></code> would substitute that shade for every pixel in the destination image that was
darker than the gray.</p>
<p>Like the blending modes, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_MIN</span></code> and <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OP_MAX</span></code> work only for color images.</p>
</section>
</section>
</section>
<section id="views-and-the-server">
<h2>Views and the Server<a class="headerlink" href="#views-and-the-server" title="Permalink to this heading">¶</a></h2>
<p>Windows lead a dual life—as on-screen entities provided by the Application Server and as
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BWindow</span></code> objects in the application. <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>s have a similar dual
existence—each <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> object has a shadow counterpart in the server. The server knows
the view’s location, its place in the window’s hierarchy, its visible area, and the current state of
its graphics parameters. Because it has this information, the server can more efficiently associate
a user action with a particular view and interpret the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s drawing instructions.</p>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BWindow</span></code>s become known to the Application Server when they’re constructed; creating a
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BWindow</span></code> object causes the server to produce the window that the user will eventually
see on-screen. A <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>, on the other hand, has no effect on the server when it’s
constructed. It becomes known to the server only when it’s attached to a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BWindow</span></code>. The
server must look through the application’s windows to see what views it has.</p>
<p>A <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> that’s not attached to a window therefore lacks a counterpart in the server.
This restricts what some functions can do. Three groups of functions are affected:</p>
<ul class="simple">
<li><p>Drawing functions—<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">DrawBitmap()</span></code>, <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">FillRect()</span></code>,
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">StrokeLine()</span></code>, and so on—don’t work for unattached views. A <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>
can’t draw unless it’s in a window.</p></li>
<li><p>The scrolling functions—<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ScrollTo()</span></code> and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ScrollBy()</span></code>—require
the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> to be in a window. Manipulations of a view’s coordinate system are carried
out in its server counterpart.</p></li>
<li><p>Functions that indirectly depend on a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s graphics parameters—such as
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">GetMouse()</span></code>, which reports the cursor location in the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s
coordinates—also require the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> to belong to a window. These functions need
information that an unattached <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> can’t provide.</p></li>
</ul>
<p>However, the functions that set and return graphics parameters—such as
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetFont()</span></code>, <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetDrawingMode()</span></code>,
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">PenLocation()</span></code>, and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetHighColor()</span></code>—are not restricted. A
view’s graphic state is kept within the server (where it’s needed to carry out drawing
instructions), but also cached by the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>. Therefore, it’s possible to assign a value
to a graphics parameter before the server knows about the view. The value is simply cached until the
view becomes part of a window’s view hierarchy; the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> then hands it to the server.
The server and the client-side cache are always kept in synch.</p>
<section id="attaching-to-a-window">
<h3>Attaching to a Window<a class="headerlink" href="#attaching-to-a-window" title="Permalink to this heading">¶</a></h3>
<p>Although you can set a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s graphics parameters before it belongs to a window and
has a counterpart in the Application Server, some of its initialization may need to wait until the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> receives an <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AttachedToWindow()</span></code> notification informing it that
it has been added to a window’s view hierarchy. For example, if a view adopts the background color
of its parent, it can only set the view color in <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AttachedToWindow()</span></code>:</p>
<div class="highlight-beapi notranslate"><div class="highlight"><pre><span></span>void MyView::AttachedToWindow(void)
{
	if ( Parent() )
		SetViewColor(Parent()-&gt;ViewColor());
	 . . .
}
</pre></div>
</div>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AttachedToWindow()</span></code> is called for each view that’s added to a window, beginning
with the root view being attached, followed by each of its children, and so on down the hierarchy.
After all views have been notified with an <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AttachedToWindow()</span></code> function call,
they each get an <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AllAttached()</span></code> notification, but in the reverse order. A parent
view that must adjust itself to calculations made by a child view when it’s attached to a window can
wait until <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AllAttached()</span></code> to do the work.</p>
<p>These two function calls are matched by another pair—<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">DetachedFromWindow()</span></code> and
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AllDetached()</span></code>—which notify <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>s that they’re about to be removed
from the window.</p>
</section>
<section id="preparing-to-draw">
<h3>Preparing to Draw<a class="headerlink" href="#preparing-to-draw" title="Permalink to this heading">¶</a></h3>
<p>A <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> doesn’t have to draw anything within its frame rectangle—it can just be a
container for other <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>s that do draw there. However, most views that you implement
will draw. And most views draw by implementing the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Draw()</span></code> function. This
function is called upon to present the view on-screen (or, when printing, on a page). It’s
implemented using the primitive drawing functions listed above. If your <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> includes
a <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code> implementation, you must include <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_WILL_DRAW</span></code> in the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s flags upon construction.</p>
</section>
<section id="the-update-mechanism">
<h3>The Update Mechanism<a class="headerlink" href="#the-update-mechanism" title="Permalink to this heading">¶</a></h3>
<p>The Application Server sends a message to a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BWindow</span></code> whenever any of the views within
the window need to be updated. The <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BWindow</span></code> then calls the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code>
function of each out-of-date <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> so that it can redraw the contents of its on-screen
display.</p>
<p>Update messages can arrive at any time. A <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BWindow</span></code> receives one when the window is first placed on
screen, or is shown after being hidden:</p>
<ul class="simple">
<li><p>The window is first placed on-screen, or is shown again after having been hidden.</p></li>
<li><p>Any part of the window becomes visible after being obscured.</p></li>
<li><p>The views in the window are rearranged—for example, if a view is resized or a child is removed from
the hierarchy.</p></li>
<li><p>Something happens to alter what a particular view displays. For example, if the contents of a view
are scrolled, the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> must draw any new images that scrolling makes visible. If one
of its children moves, it must fill in the area the child view vacated.</p></li>
<li><p>The application forces an update by “invalidating” a view, or a portion of a view.</p></li>
</ul>
<p>As update messages arrive, they jump to the head of the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BWindow</span></code>’s message queue.</p>
</section>
<section id="forcing-an-update">
<h3>Forcing an Update<a class="headerlink" href="#forcing-an-update" title="Permalink to this heading">¶</a></h3>
<p>When a user action or a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> function alters a view—if the view is scrolled, for
example—an update message is sent and the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code> function
is automatically called. But if the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code> function depends on some other state
that’s defined by your application, you need to tell the Application Server that your
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> needs an update message. You do this by invoking <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Invalidate()</span></code> function.</p>
<p>For example, let’s say your <code class="docutils literal notranslate"><span class="pre">D2DView</span></code> subclass connects some dots by reading points out of a
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BList</span></code> and drawing lines between them:</p>
<div class="highlight-beapi notranslate"><div class="highlight"><pre><span></span>void D2DView::Draw(BRect update)
{
	int32 i = 1;
	if (dotList-&gt;CountItems() &gt; 1) {
		MovePenTo(*(BPoint*)dotList-&gt;ItemAt(0);
		while (i &lt; dotList-&gt;CountItems())
			StrokeLine(*(BPoint *)dotList-&gt;ItemAt(i++));
	}
}
</pre></div>
</div>
<p>Each “dot specification” is added through <code class="docutils literal notranslate"><span class="pre">DotView</span></code>’s <code class="docutils literal notranslate"><span class="pre">AddDot()</span></code> function. <code class="docutils literal notranslate"><span class="pre">AddDot()</span></code> includes a
call to <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Invalidate()</span></code> in order to force the view to be redrawn:</p>
<div class="highlight-beapi notranslate"><div class="highlight"><pre><span></span>void D2DView::AddDot(BPoint p)
{
	dotList-&gt;AddItem(new BPoint(p));
	Invalidate();
}
</pre></div>
</div>
<section id="forcing-an-update-while-responding-to-an-event">
<h4>Forcing an Update while Responding to an Event<a class="headerlink" href="#forcing-an-update-while-responding-to-an-event" title="Permalink to this heading">¶</a></h4>
<p>The hook functions that respond to user events—<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">KeyDown()</span></code>,
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">MouseDown()</span></code>, and so on—are executed in the same thread that receives window
update messages. If you do something in your implementation of one of these hook functions that
causes an update, the update message won’t be processed until your hook function exits. If your hook
function does a lot of processing, your interface can become unresponsive.</p>
<p>To get around this problem, call <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BWindow</span></code>’s <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">UpdateIfNeeded()</span></code>
function from within your hook functions’ implementations. <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">UpdateIfNeeded()</span></code>
forces any pending update messages to be processed immediately. The function doesn’t return until
the “dirty” views are all done re-drawing. (Note that <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">UpdateIfNeeded()</span></code> only
works from within the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BWindow</span></code>’s message loop thread.)</p>
<p>For example, let’s say you want to add a random dot (within a 100x100 square) everytime the user
hits a key:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">D2DView</span><span class="p">::</span><span class="n">KeyDown</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">bytes</span><span class="p">,</span> <span class="n">int32</span> <span class="n">numBytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AddDot</span><span class="p">(</span><span class="n">BPoint</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">100</span><span class="p">,</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">100</span><span class="p">);</span>
	<span class="n">Window</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">UpdateIfNeeded</span><span class="p">();</span>
	<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">AddDot()</span></code> calls <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Invalidate()</span></code>, we know that there’s an update message
pending. However, the update won’t normally be processed until <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">KeyDown()</span></code> exits,
so we call <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">UpdateIfNeeded()</span></code>, which sees the update and calls <code class="docutils literal notranslate"><span class="pre">D2DView</span></code>’s
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code> function. When <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code> is finished,
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">UpdateIfNeeded()</span></code> returns and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">KeyDown()</span></code> continues.</p>
</section>
</section>
<section id="erasing-the-clipping-region">
<h3>Erasing the Clipping Region<a class="headerlink" href="#erasing-the-clipping-region" title="Permalink to this heading">¶</a></h3>
<p>Just before sending an update message, the Application Server prepares the clipping region of each
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> that is about to draw by erasing it to the view background color. Note that only
the clipping region is erased, not the entire view, and perhaps not the entire area where the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> will, in fact, draw.</p>
<p>The server forgoes this step only if the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>’s background color is set to
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_TRANSPARENT_COLOR</span></code>. See “The View Color” above.</p>
</section>
<section id="drawing-during-an-update">
<h3>Drawing during an Update<a class="headerlink" href="#drawing-during-an-update" title="Permalink to this heading">¶</a></h3>
<p>While drawing, a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> may set and reset its graphics parameters any number
of times—for example, the pen position and high color might be repeatedly reset so that whatever is
drawn next is in the right place and has the right color. These settings are temporary. When the
update is over, all graphics parameters are reset to their initial values.</p>
<p>If, for example, <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code> sets the high color to a shade of light blue, as shown
below,</p>
<div class="highlight-beapi notranslate"><div class="highlight"><pre><span></span>SetHighColor(152, 203, 255);
</pre></div>
</div>
<p>it doesn’t mean that the high color will be blue when <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code> is called next. If
this line of code is executed during an update, light blue would remain the high color only until
the update ends or <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetHighColor()</span></code> is called again, whichever comes first. When
the update ends, the previous graphics state, including the previous high color, is restored.</p>
<p>Although you can change most graphics parameters during an update—move the pen around, reset the
font, change the high color, and so on—the coordinate system can’t be touched; a view can’t be
scrolled while it’s being updated. If the view’s coordinate system were to change, it would alter
the current clipping region and confuse the update mechanism.</p>
</section>
<section id="drawing-outside-of-an-update">
<h3>Drawing outside of an Update<a class="headerlink" href="#drawing-outside-of-an-update" title="Permalink to this heading">¶</a></h3>
<p>Graphics parameters that are set outside the context of an update are not limited; they remain in
effect until they’re explicitly changed. For example, if application code calls
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code>, perhaps in response to an interface message, the parameter values that
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code> last sets would persist even after the function returns. They would
become the default values for the view and would be assumed the next time <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code>
is called.</p>
<p>Default graphics parameters are typically set as part of initializing the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> once
it’s attached to a window—in an <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AttachedToWindow()</span></code> function. If you want a
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code> function to assume the values set by
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AttachedToWindow()</span></code>, it’s important to restore those values after any drawing the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code> does that’s not the result of an update. For example, if a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BView</span></code>
invokes <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetHighColor()</span></code> while drawing in response to an interface message, it will
need to restore the default high color when done.</p>
<p>If <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Draw()</span></code> is called outside of an update, it can’t assume that the clipping
region will have been erased to the view color, nor can it assume that default graphics parameters
will be restored when it’s finished.</p>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Haiku.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>